v0.x
====
- Implementar validação de modelo (IModelValidator)
- Gerenciador de notificações genérico
  > Implementar opção ZeroMQ
  > Implementar repositório genérico para Notificações?
    * INotificationManagerStore<>?
- Alterar IStorage<>.Search para utilizar IDataLimiter<> e assim acessar Sorter()
  > Isso deixará as pesquisas uniformes (Find, Get, Search e LimitedSearch)
  > Ou deixar como está. Firmar o conceito e relação entre Find, Get, Search e LimitedSearch
    com seus respectivos objetivos. Mas registrar log com Warning, para quando for utilizado
    um método que não precisa de um recurso e ele for configurado em .Query().
    Ex: .Query().AddSorter(), e depois chamar .Search()
    - Neste cenário o log seria um problema:
      > Quando inicializamos a consulta com "Query()", criamos um objeto fora do contexto
        de injeção de dependência. Neste caso, não temos um objeto ILogger<> ou algo semelhante
        e genérico.
      > A solução seria informar um logger como parâmetro "Query(myLogger)", e isso seria feio,
        além de obrigar o usuário a informar um logger que pode nem mesmo ser necessário.

v1.0
====
- Implementar internacionalização/localização
- Rever conceito de Offset/Limit e Page
- Implementar validação
- Remover necessidade de objetos de assinatura
  > IDataModuleSignature
  > IStorageSignature
- Repensar DataModule<>. Talvez usar a idéia de BusinessService e DataService?
  (ou StorageService, PersistenceService)
- Renomear Storage para Store?
- Implementar Data.Dapper
  > Implementar suporte a SQL puro
  > IDataFilter, Sorter, Get(), Find(), Search(), etc.
- Adicionar suporte a consultas com SQL puro mesmo no EntityFramework
- Publicar documentação online
  > API
  > Tutoriais

v2.0
====
- Estabilizar conceito de BusinessObject
- Utilizar operações de Bulk com alguma biblioteca ao invés iteração simples

vNext
=====
- Implementar Data para cenário na nuvem
- Implementar Data para cenário em sistema de arquivos
